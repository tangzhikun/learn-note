make与makefile

**make工具**：它可以帮助我们找出项目里面修改变更过的文件，并根据依赖关系，找出受修改影响的其他相关文件，然后对这些文件按照规则进行单独的编译，这样一来，就能避免重新编译项目的所有的文件。

**Makefile文件**：上面提到的规则、依赖关系主要是定义在这个Makefile文件中的，我们在其中合理地定义好文件的依赖关系之后，make工具就能精准地进行编译工作。

Makefile格式

目标1：依赖

​	命令

目标2：依赖

​    命令

如果只输入make，则默认为目标1，输入make 目标，先执行依赖，然后依次执行命令。命令只有当目标不存在或依赖文件的修改时间比目标文件还新时才会执行。如果不生成目标文件，那么就需要把目标定义成伪目标，避免有同名文件导致错误。

例如

``` makefile
.PHONY
clean:
	rm test
```

使用``make clean``删除掉中间变量，方便下一次编译使用。

使用自动化变量“\$@”表示目标文件“​\$(TARGET)”，使用自动化变量“\$^”表示所有的依赖文件即“$(OBJS)”。

|      |                                                              |
| :--: | :----------------------------------------------------------: |
|  $@  |                         匹配目标文件                         |
|  $%  |                   仅匹配“库”类型的目标文件                   |
|  $<  |                    依赖中的第一个目标文件                    |
|  $^  |        所有的依赖目标，如果依赖中有重复的，只保留一份        |
|  $+  |         所有的依赖目标，即使依赖中有重复的也原样保留         |
|  $?  |                   所有比目标要新的依赖目标                   |
|  $*  | 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。 |

``gcc -o $@ $^``利用目标的依赖文件，通过``gcc``编译生成目标文件，这里的\$@指目标文件，\$^指依赖文件。

## 变量的基本赋值

知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：

-  简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
-  递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
-  条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。
-  追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。

使用=递归赋值的话，之前的所有变量只要是与被递归赋值相关的变量都会被重新赋该变量的新值。使用:=简单赋值则只会对当前语句有效。

?=类似于``#ifndef``如果被赋值的变量未定义则赋值，若已经定义则语句无效。因为makefile中的变量允许有多个值，故可以使用+=追加赋值对变量增加一个值。

这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。这样同样提高了 make 的执行效率，同时也不用担心目标和文件名重名而使我们的编译失败。

### 函数

``$(addprefix <prefix>, <name>``增加前缀

``$(wildcard PATTERN)`` 提取出所有满足条件的文件名

``$(foreach <var>,<list>,<text>)``函数的功能是：把参数`<list>`中的单词逐一取出放到参数`<var>`所指定的变量中，然后再执行`<text>`所包含的表达式。每一次`<text>`会返回一个字符串，循环过程中，`<text>`的返所返回的每个字符串会以空格分割，最后当整个循环结束的时候，`<text>`所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。所以`<var>`最好是一个变量名，`<list>`可以是一个表达式，而`<text>`中一般会只用`<var>`这个参数来一次枚举`<list>`中的单词。

``$(if <condition>,<then-part>)``或者``if<condition>,<then-part>,<else-part>)``

**常用函数**：``$(call <expression>,<parm1>,<parm2>,<parm3>,...)``call 函数是唯一一个可以用来创建新的参数化的函数。我们可以用来写一个非常复杂的表达式，这个表达式中，我们可以定义很多的参数，然后你可以用 call 函数来向这个表达式传递参数。

当 make 执行这个函数的时候，`expression`参数中的变量$(1)、$(2)、$(3)等，会被参数`parm1`，`parm2`，`parm3`依次取代。而`expression`的返回值就是 call 函数的返回值。

### 命令的编写

如果规则的命令行以字符“@”开始，则 make 在执行的时候就不会显示这个将要被执行的命令。典型的用法是在使用`echo`命令输出一些信息时。