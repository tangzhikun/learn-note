---
typora-copy-images-to: ./
---







## 计网

#### MAC（Media Access Control Address）地址

直译为**媒体存取控制位址**，也称为**局域网地址**（LAN Address），**MAC位址**，**以太网地址**（Ethernet Address）或**物理地址**（Physical Address），它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 。

### IP地址

IP地址分为网络号和主机号，子网掩码为1的部分为网络号，通常子网掩码为255.255.255.0，对应的网络号为IP地址的前三个byte，最后一个byte为主机号。

当主机号部分全部为0或者全部为1（255）时，代表两种特殊的含义，主机号部分全部为0代表**整个子网**而不是子网中的某台设备，主机号全部为1代表向子网上所有设备发送包，即广播。

### OSI七层模型及各层的作用

1. **应用层**：

   应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。

2. **表示层**

   表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。

3. **会话层**

   会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。

4.  **传输层**

   传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

5.  **网络层**

   两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把运输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。

6. **数据链路层**

   数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。

7. **物理层**

   作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。

   

#### HTTP

HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。

#### HTTPS

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：

① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；

② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。

③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。

④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。

⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secret，并且该报文是经过证书中的公钥加密过的。

⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secret 加密的。

⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。

⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。

当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。

#### GET和POST的区别

* get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。
* get 请求只支持 URL 编码，post 请求支持多种编码格式。
* get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。
* get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制
* get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。
* get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。

#### 状态码

| 分类 | 分类描述                                                     |
| ---- | ------------------------------------------------------------ |
| 1XX  | 指示信息：表示请求正在处理                                   |
| 2XX  | 成功：表示请求已被成功处理完毕                               |
| 3XX  | 重定向：要完成的请求需要进行附加操作                         |
| 4XX  | 客户端错误：请求有语法错误或者请求无法实现，服务器无法处理请求 |
| 5XX  | 服务端错误：服务器处理请求错误                               |

常见状态码：

200,204,301,302,400,403,404,409,500,502,503

200：请求成功；204：请求成功但无内容返回；301：永久重定向；400：语法错误；403：拒绝访问；404：找不到资源；500：服务器错误；502：网关和正向代理服务器错误；503：服务器宕机

### TCP(Transfer Control Protocol)三次握手

1. 客户端向服务端发送一个SYN包，标志位为SYN，序号Seq=x（x一般为1），客户端进入SYN-SENT阶段
2. 服务端处在Listen状态，在接受到客户端的SYN包后，返回一段TCP报文（SYN+ACK包），标志位为SYN和ACK，序号Seq=y，确认号ACK=x+1，表示收到客户端的序号Seq并将其值加一作为自己的确认号ACK的值，随后服务端进入SYN-RECV阶段
3. 客户端接受到SYN+ACK包后，这时客户端可以确定从服务端正常的向客户端发送数据，因此客户端进入ESTABLISHED状态，并返回一段报文，标志位ACK表示确认收到服务器端同意连接的信号，序号Seq = x + 1,表示收到服务端的确认号，并将其作为自己的序号值。
4. 服务端接收到客户端的确认收到报文（ACK包）后，这是服务器可以确认服务端可以正常的向客户端信息，客户端也可以正常的返回服务端信息，这是服务端进入ESTABLISHED状态。

![image.png](.\1614160878-FiFlkq-image.png)

TCP在其协议中使用大量的标志位或者说一位布尔域来控制连接状态，其中SYN（创建一个连接）、FIN（终结一个连接）、ACK（确认接收到的数据）

TCP会话的每一段都包含一个32位的**序列号**Sequence，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接受端则通过**确认号**用来通知发送端数据成功接受。

### 四次挥手

1. 客户端向服务端发送一段TCP报文表明其想要释放TCP连接，其中标记位为FIN，表示请求释放连接；序号为Seq = u;随后客户端进入FIN-WAIT-1阶段，即半关闭阶段，并且停止向服务端发送通信数据。
2. 服务端接收到客户端请求断开连接的FIN报文后，结束ESTABLISHED阶段，进入CLOSE-WAIT阶段并返回一段TCP报文，其中**标记位为ACK**，序号Seq=v；确认号Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加一作为本段报文确认号Ack的值；随后服务器开始准备释放服务器到客户端方向上的连接。
3. 客户端收到服务器发送过来的TCP报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束FIN-WAIT-1阶段进入FIN-WAIT-2阶段。服务端在发出ACK确认报文后，服务器会将遗留待传的数据发送给客户端，传输完成后，即结束CLOSE-WAIT阶段，服务端做好了释放服务端到客户端的连接准备，再一次向客户端发出一段报文，其中**标记位为FIN和ACK**，表示已经准备好释放连接了；序号Seq = w；确认号Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加一作为本段报文确认号Ack的值；此时服务端结束CLOSE-WAIT阶段，进入LAST-ACK阶段，停止向客户端发送数据。
4. 客户端收到从服务端发送的TCP报文，确认了服务端已经做好了释放连接的准备，于是结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器发送一段报文，其中：标记位为ACK，序号Seq = u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；确认号为Ack = w + 1,表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。

![四次挥手.png](.\1612459478-ajInIu-四次挥手.png)



### 如果三次握手的时候每次握手的信息对方没有收到会怎么样？

1. 若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。
2. 若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。
3. 若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态。

### TCP确认应答与超时重传机制

**确认应答机制（ACK）**：TCP将每个字节的数据都进行了编号，即为序列号，每一个ACK都带有对应的确认序列号，意思是告诉发送者，我们已经收到了哪些数据，下一次发送数据应该从哪里开始。例如TCP发送1-1000字节的数据，这时返回的ACK包序列号为1001，即下一次发送的数据从1001开始。

**超时重传机制**： 

主机A向主机B发送数据，有两种情况可以会导致超时重传，

第一种情况是主机A向主机B发送数据，发送过程丢包了，主机B未收到数据，这时导致超时重传，经过一段特定的时间间隔，主机A向主机B重发数据。

第二种情况是主机A未收到主机B返回的ACK信号，同样会导致主机A认为主机B未收到数据，同样会经过一段特定的时间间隔，主机A向主机B重发数据，但这时主机B已经接受到了这一段数据，这时主机B会根据序列号去除掉重复的包。

### CLOSE-WAIT与TIME-WAIT的状态和意义

CLOSE-WAIT是指在服务端接收到客户端发送的结束请求后，返回ACK包并进入CLOSE-WAIT阶段，在CLOSE-WAIT阶段，服务端将剩余的数据全部发送，发送完成后返回ACK+FIN包，结束CLOSE-WAIT阶段，进入LAST-ACK阶段。意义是需要等待服务端将剩余的数据包发送完毕。

TIME-WAIT是指客户端在接收到服务端返回的FIN+ACK包后，向服务端发送最后一次ACK包后，进入TIME-WAIT阶段，TIME-WAIT阶段持续时间为**2MSL**（Maximum Segment Lifetime一段TCP报文在传输过程中的最大生命周期）。TIME-WAIT阶段的意义是需要确认服务端接受到了ACK包，将该端口的连接关闭，因为存在超时重传机制，若服务端未接收到ACK包，会重复向客户端返回FIN+ACK包，若不进入TIME-WAIT阶段会导致有可能服务端未能成功的将该端口的连接关闭，导致下一次连接时接收到上一次连接的数据包。

### 为什么会发生TCP粘包和拆包

1. 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。
2. 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。
3. 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。
4. 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。

### TCP报文中包含哪些信息

![TCP报文格式.png](.\1612460289-ImAroH-TCP报文格式.png)

传输数据的简要过程如下：

**1) 发送数据** ：服务器向客户端发送一个带有数据的数据包，该数据包中的序列号和确认号与建立连接第三步的数据包中的序列号和确认号相同；

**2) 确认收到** ：客户端收到该数据包，向服务器发送一个确认数据包，该数据包中，序列号是为上一个数据包中的确认号值，而确认号为服务器发送的上一个数据包中的序列号+所该数据包中所带数据的大小。
数据分段中的序列号可以保证所有传输的数据按照正常的次序进行重组，而且通过确认保证数据传输的完整性。

### UDP（User Data Protocol)

1. UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
2.  由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。
3. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
4. 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。
5. UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
6. UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

### TCP如何保障传输的可靠性

1. **校验和**：在数据的传输过程中将每个发送数据段都看作16进制的整数；将这些整数加起来，进位不能丢补在最后面，最后取反得到校验和。
   发送方：计算校验和并且对校验和进行填充。
   接收方：以相同的方式计算校验和并且与发送方的校验和进行比对。
2. **确认应答与序列号：**序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
   确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。
   序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。
3. **超时重传**：发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。
4. **连接管理**：三次握手，四次挥手。可靠的连接时可靠性的前提。
5. **流量控制：**在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。
6. **拥塞控制：**TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。
   所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。
   拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。
7. **

### ARP地址解析协议

在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标的IP地址，不知道其MAC地址，因此需要使用地址解析协议（ARP协议）。解析过程如下：

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机需要发生数据时，首先在ARP列表中检查是否有目标IP地址对应的MAC地址，如果存在则直接发送，如果不存在就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。
3. 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。
4. 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

### MAC地址与IP地址分别有什么作用

MAC地址是数据链路层和物理层使用的地址，是写在网卡上的**物理地址**，MAC地址用来定义网络设备的位置，每个网络设备的MAC地址是唯一的。

IP地址是网络层和以上各层使用的地址，是一种逻辑地址。IP地址用来区别网络上的计算机。

### 为什么有了MAC地址还需要IP地址

如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪一个子网，不然每一次路由器收到数据包时都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是说最多总共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256 T 的内存，这显然是不现实的。

和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。

### 为什么有了IP地址还需要MAC地址

只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，**我们需要 MAC 地址来区分不同的设备**。

### 物理层主要做什么？

作为 OSI 参考模型最低的一层，物理层是整个开放系统的基础，该层利用传输介质为通信的两端建立、管理和释放物理连接，实现比特流的透明传输。物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，其尽可能地屏蔽掉不同种类传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。

### ARP攻击

在ARP解析的过程中，局域网上的任何一台主机如果接受到一个ARP应答报文，并不会去检测这个报文的真实性，而是直接计入自己的ARP缓存表中。并且这个 ARP 表是可以被更改的，当表中的某一列长时间不适使用，就会被删除。ARP 攻击就是利用了这一点，攻击者疯狂发送 ARP 报文，其源 MAC 地址为攻击者的 MAC 地址，而源 IP 地址为被攻击者的 IP 地址。通过不断发送这些伪造的 ARP 报文，**让网络内部的所有主机和网关的 ARP 表中被攻击者的 IP 地址所对应的 MAC 地址为攻击者的 MAC 地址。**这样所有发送给被攻击者的信息都会发送到攻击者的主机上，从而产生 ARP 欺骗。通常可以把 ARP 欺骗分为以下几种：



## socket网络编程

#### 1.socket() 创建套接字

使用``<sys/socket.h>``头文件中socket()函数来创建套接字，原型为：

``int socket(int af, int type, int protocol)``

af为地址簇，常用的有``AF_INET``和``AF_INET6``分别代表IPv4和IPv6。
type为数据传输方式/套接字类型，常用的有``SOCK_STREAM``和``SOCKET_DGRAM``，分别表示面向连接的套接字和无连接的套接字。
protocol表示传输协议，常用的有``IPPROTO_TCP``和``IPPROTO_UDP``，分别表示TCP和UDP传输协议。

### 2. bind() 绑定端口和IP

将套接字和特定的IP地址和端口绑定起来。

``int bind(int sock, struct sockaddr *addr, socklen_t addrlen);``

sock为socket文件描述符，addr为sockaddr结构体变量的指针，addrlen为addr变量的大小。

```c++
//创建套接字
int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

//创建sockaddr_in结构体变量
struct sockaddr_in serv_addr;
memset(&serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充
serv_addr.sin_family = AF_INET;  //使用IPv4地址
serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //具体的IP地址
serv_addr.sin_port = htons(1234);  //端口

//将套接字和IP、端口绑定
bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
```

### 3. connect() 建立连接

connect()函数用来建立连接

``int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen);``

### 4. listen() 被动监听

``int listen(int sock, int backlog); ``

sock为需要监听的套接字，backlog为请求队列的最大长度。
当套接字正在处理客户端请求时，如果有新的请求进来，必须将请求放入缓冲区，缓冲区的长度可以通过backlog参数指定，可以通过并发量来确定，如果并发量小的话可以是10或者20.

### 5. accept() 接受请求

 ``int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);``

accept()返回一个新的套接字来和客户端通信，addr保存了客户端的IP地址和端口号，而sock是服务端的套接字，后面和客户端通信时，要使用这个新生成的套接字，而不是原来的套接字。

accept()会阻塞程序执行直到有新的请求到来。

### 6. write()/read() 发送与接收

Linux不区分套接字文件和普通文件，像读写正常文件一样使用write()和read()对套接字中写入数据和读取数据。

``ssize_t write(int fd, const void *buf, size_t nbytes);``

``ssize_t read(int fd, void* buf, size_t nbytes);``

fd文件描述符，buf缓冲区地址，写入/读出数据的字节数。



### socket缓冲区

每个socket被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。write()/read()都不会立即向网络中发送数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。

I/O缓冲区特性：

* I/O缓冲区在每个TCP套接字中单独存在；
* I/O缓冲区在创建套接字时自动生成；
* 即使关闭套接字也会继续传送输出缓冲区遗留的数据；
* 关闭套接字将丢失输入缓冲区的数据。



### 阻塞模式

* 输入输出缓冲区默认大小8k，如果在使用write()时，缓冲区可用空间大小小于需要发送的数据，那么这时候write()会被阻塞执行，直至缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒write()继续写入。
* 如果TCP协议正在发送数据，那么输出缓冲区会被锁定，不允许写入，write()也会被阻塞。
* 如果要写入的数据大于缓冲区，那么将会把数据分批写入。直到所有数据写入到缓冲区write()才会返回。
* 如果缓冲区无数据，read()会被阻塞，直到有数据到来。
* 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据不断积压，直到有read()函数再次读取
* 直到读取到数据后read()函数才会返回，否则就一直被阻塞。

## HTTP

### HTTP请求报文结构

HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据

1. 请求行
   请求行有请求方法字段（GET、POST等等）、URL字段和HTTP协议版本字段（HTTP/1.1、HTTP/2.0等）3个字段组成，他们用空格分隔。
2. 请求头部
   如果有必要，客户程序还可以选择发送其他的请求头，大多数请求头并不是必须的，**但Content-Length除外**。对于POST请求来说Content-Length必须出现。
3. 空行
   空行的作用是通过一个空行，告诉服务器请求头部到此为止。
4. 请求数据
   若方法字段是GET，则此项为空，没有数据
   若方法字段是POST，则通常来说此处放置的就是要提交的数据。

![img](.\20160921092902556.jpg)

### HTTP响应报文

HTTP响应报文由三部分组成：响应行，响应头，响应体。

1. 响应行
   响应行由协议版本，状态码和描述组成，比如``HTTP/1.1 200 OK``

2. 响应头
   响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。

   设置HTTP响应头往往和状态码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401(Unauthorized)状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。

3. 响应体
   响应体就是响应的信息体，如果请求的是纯数据就返回纯数据，如果请求的是HTML页面，那么就返回HTML页面。
   ![这里写图片描述](.\20160921092902557.jpg)

## HTTPS

HTTPS即 HTTP over TLS，运行在TLS协议上的安全的HTTP协议。

### SSL握手

SSL握手的过程都是明文的，因此SSL握手的重点就在于怎么在不安全的网络中安全的进行密钥交换。

对称加密与非对称加密：对称加密指的是加密与解密过程使用相同的密钥，加密速度快，非对称加密是指解密的一方将私钥保存，将公钥发送给任何请求的用户，用户使用公钥进行加密，服务端使用私钥进行解密。

RSA交换密钥步骤：

1. 客户端给出协议版本号，一个随机数（Random1），以及客户端支持的加密方法；
2. 服务端确认使用的加密方法，并给出数字证书，以及随机数（random2);
3. 客户端确认数字证书有效，生成一个新的随机数（premaster secret），并使用数字证书中的公钥，利用RSA算法加密这个随机数，发送给服务端；
4. 服务端使用自己的私钥，获取客户端发送来的随机数（premaster secret);
5. 客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成对话密钥（master secret），用来加密接下来的整个对话过程。

![image-20210407161327281](.\image-20210407161327281.png)

## RSA加密过程

1. 选择两个较大的素数p和q，n = p * q, z = (p - 1) * (q - 1)；

2. 选择公钥e，公钥e满足条件e与z互素，然后使用公钥进行加密，若被加密信息为m，加密后的值为c，m与c满足
   $$
   c = m^e mod(n)
   $$

3. 选择私钥d，私钥d满足条件$$ (e * d) mod(z) = 1$$，然后使用私钥进行解密，若加密后信息为c，解密后信息为m，c与m满足
   $$
   m = c^d mod(n)
   $$

过程推导：
实际上是证明对于任意两个素数p和q，n = p * q, z = (p - 1) * (q - 1)，存在与z互素的数e，以及与e对应的d满足e*d mod(z) = 1，使得$$(m^emod(n))^dmod(n) = m$$。

根据数论中的$$m^{ed} mod n = m^{ed mod z}mod n$$。
为什么需要e与z互素？只有在e与z互素的情况下，才存在d使得$$ (e * d) modz = 1$$，且这个d是唯一的。
被加密数的范围为0到n-1，因为要对n取模，因此不能超过n。

![image-20210423154943360](.\image-20210423154943360.png)

对于特定的公钥，私钥是唯一的，因此对于破解非对称加密需要破解出两个素数p，q。为了提高破解难度，也为了提高被加密数的范围，我们需要选择较大的p，q。

## 网络编程实战

联机五子棋：

服务端创建socket之后需要使用listen开始监听，客户端创建socket之后需要connect连接目标

### 面试常考题

1. **详细介绍一下TCP的三次握手机制，为什么要三次握手?**
   （为什么TCP要握手？握手为什么是三次？）
   TCP的重要特性是可靠性，即如果消息发送失败则必须要重复发送直到成功，对消息进行编号，即sequence，确定收发了哪个消息。在发送消息之前需要知道对方的序列号，因此需要通过握手建立连接获取。

2. **能否简单介绍HTTP协议中缓存的处理流程？**

   ![image-20210406105003727](.\image-20210406105003727-1617761482998.png) 客户端，正向代理服务器，反向代理服务器/负载均衡，

3. **地址栏键入URL之后，网络世界发生了什么？**
   DNS协议：域名转换为IP地址，客户端中保存有DNS缓存，如果缓存命中，则可以直接获取IP地址，若未命中则包含正向代理，反向代理再到源服务器，获取IP地址。
   HTTP协议编码：浏览器会将URL转换为HTTP请求的格式。
   网络分层： 一层一层的将报文包装，最后发送出去。

   1. DNS域名解析；
   2. 建立TCP连接；
   3. 发送HTTP请求；
   4. 服务器处理请求；
   5. 返回响应结果；
   6. 关闭TCP连接；
   7. 浏览器解析HTML；
   8. 浏览器布局渲染。
   
4. **使用HTTP长连接有哪些优点？**
   减少握手次数，减少慢启动影响，
   有什么缺点：TCP协议是字符流协议，如果在一个长连接中传很多个请求，一个没有传输完成就不能传输第二个，造成队头阻塞

5. **介绍下CLOSE_WAIT状态产生的原因？**
   TCP在建立连接之后便不再区分server与client，在结束连接时，客户端与服务端均可以发起结束连接，区分为主动发起结束请求的**主动端**与被动接受结束请求的**被动端**。在CLOSE_WAIT阶段全双工连接进入到半打开的状态，只允许被动端向主动端发送数据，直至全部数据发送完成。一般在工程上出现CLOSE_WAIT状态大概率是出现BUG。

6. **能介绍下多播是怎么样实现的吗？**
   只在局域网中进行多播，TCP协议因为是点对点的连接，所以不支持多播。多播分为两类，广播（IP地址全为1）和组播（只对一部分机器发送）。
   多播的好处：对于单播如果需要向多个机器发送数据，需要CPU将数据拷贝多份，分别发送，而多播是由网络设备交换机和路由器来复制直接转发，对于发送端有性能提升。

7. **服务器的最大并发连接数是多少？**
    （怎么样实现高并发？Linux下的高并发优化？）

8. **TCP和UDP协议该如何选择？**
   UDP优点：一对多通讯，效率高，简单，实时性更好，无队头阻塞问题。
    TCP优点：传递任意长度消息，可靠，流量控制，拥塞控制（滑动窗口，网络链路控制）。

9. **TLS/SSL协议？**
   PKI证书体系，密钥交换协议，对称加密算法。

10. **HPACK编码**
    动态表，静态表，静态huffman，整数编码。

11. **Cookie和Session**
     HTTP协议是无状态的，前后两次请求时相互独立的，没有必然联系的，它并不会跟踪用户信息，Cookie和Session就是为了弥补这一不足，而引入的一种机制。Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。
      **Cookie**实际是一小段文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，当浏览器再请求该网站时，浏览器把URL+cookie一同提交。服务器检查该Cookie，以此来辨认用户状态。
      Session的主要作用就是通过服务端记录用户的状态，因为HTTP协议是无状态的，服务端给特定的用户创建特定的Session之后就可以标识这个用户并且跟踪这个用户了。Session保存在客户端，Cookie保存在服务端。
      当网页要发送HTTP请求时，浏览器会先检查是否有相应的cookie，有则自动添加request header中的cookie字段中，这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们去做，因此对于那些每次都需要携带的信息（例如身份认证信息）就特别适合放在cookie中，其他类型的数据就不合适了。

12. **Web网页请求的历程**

     1. 准备：DHCP分配IP地址
        DHCP(Dynamic Host Configuration Protocol)：
        1）当主机连接上网线之后，此时主机还未分配IP地址，主机会生成一个DHCP请求报文，并将这个报文放入具有目的地端口67（DHCP的服务器）和源端口68（DHCP客户）的UDP报文段，该UDP报文段目标IP地址为（255.255.255.255），即广播，源IP地址（0.0.0.0），因为此时主机还未分配IP地址。目标MAC地址为（FF：FF：FF：FF：FF：FF），即广播对应的MAC地址，源MAC地址为当前主句NIC上对应的MAC地址。
        2）路由器接收到请求后，一层一层的向上交付，DHCP服务器选择一个可用的IP地址分配给主机。DHCP服务器会生成一个包含分配的IP地址，DNS服务器的IP地址，默认网关路由器的IP地址和子网块（类似于68.85.2.0/24），即网络掩码，当前子网的前缀放入一个DHCP ACK的报文中，报文的目标MAC地址是主机的MAC地址，路由器发送给交换机，交换机根据之前接收到的主机发送的DHCP请求，将DHCP ACK报文发送给主机。
        3）主机接收到DHCP报文，并交付给应用层，主机记录下IP地址与DNS服务器IP地址，以及网关地址。主机将向网关地址发送对子网以外的数据报文。此时主机以及具备访问网络的基础条件。
     2. 仍在准备：DNS和ARP
        DNS（Domain Name System)：
        4）主机上的操作系统生成一个DNS查询报文，将URL放入到DNS报文中的问题段，该DNS查询报文使用UDP协议，目标端口53（DNS服务器），源端口为操作系统分配的端口，目标IP地址为之前获取的DNS服务器IP，源IP地址为主机的IP地址，因为目标IP地址不在子网内，此时需要将报文发送给网关路由器，但是此时未获取网关路由器的MAC地址，我们还需要通过ARP协议获取网关路由器的MAC地址。
        5）主机生成一个具有目标IP地址，即网关路由器的IP地址的ARP查询报文，该查询报文的目标MAC地址为FF:FF:FF:FF:FF:FF，即全1，广播该报文，该网关下的所有主机都会接收到该查询报文，并检查该报文中的目标IP地址是否与自己的IP地址相同，如果相同则会返回一个ARP ACK报文，将自己的IP地址发送给主机。网关路由器会发现目标IP地址匹配网关路由器的IP地址，它将发送ARP ACK报文给主机。
        6）主机从ARP ACK报文中提取网关路由器的MAC地址，并将MAC地址放入DNS查询报文的首部，发送给交换机，交换机再发送给路由器。
     3. 仍在准备：域内路由选择到DNS服务器
        7）路由器根据转发表将数据报文发送到下一跳，不断的转发，直到到达DNS服务器，DNS服务器抽取出DNS查询报文，在它的DNS数据库中查找URL，并找到对应的IP地址，可能存在负载均衡，即一个URL对应多个IP地址，DNS服务器轮询这些IP地址，确保每个IP地址被解析的概率是相同的。DNS服务器形成一个包含URL到IP地址的映射的DNS ACK报文，放入UDP报文段中，该报文段放入寻址到主机的IP数据报中，通过相同的路径发送到主机。
        8）主机从DNS报文中抽取出URL对应的IP地址。
     4. Web客户-服务器交互：TCP、HTTP/HTTPS
        9）主机获取了URL对应的IP地址，即可以与服务器建立TCP连接。主机通过该连接向服务器发送HTTP GET请求已经获取服务器返回的数据报文。在主机生成TCP套接字时，主机必须要先与服务器通过三次握手建立连接。主机需要先发送一个目标端口80（专门针对HTTP的端口），或者目标端口443（专门针对HTTPS的端口）的TCP SYN报文，即SYN置位，将报文一层一层封装后发送给服务器，服务器返回一个SYN ACK报文，主机发送一个ACK报文，至此建立起TCP连接，并将HTTP GET请求发送给服务器。
        10）服务器接收到GET请求后，生成一个HTTP ACK报文，将请求的Web页内容放入HTTP响应报文，并将报文通过TCP连接发送给主机，主机Web程序从套接字中读取Web网页的html，并将html内容渲染并显示，至此完成从接入网线到敲下URL到显示网页内容的全部过程。

     

    

    
    
    
    
      
    
      





