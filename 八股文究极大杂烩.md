# 究极八股文

## C++语言特性

1. **面向对象的三大特性：封装、继承、多态**
   封装：外部对象不能直接访问类里的private、protected成员，类提供public的成员函数，利用成员函数实现对private、protected成员的访问。通过这样的方式实现数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系；

   继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。
   多态：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

2. **类的访问权限：private、protected、public**
   private：仅有同类的对象可以访问，同类的不同对象也是可以互相访问。
   protected：子类和同类的对象可以访问
   public：所有均可以访问
   protected继承：父类中public、protected的对象在子类中为protected类型，private类型的对象仍为private；
   public继承：父类对象的类型在子类中均不改变

3. **类的构造函数、析构函数、赋值函数、拷贝构造函数**

   一般情况下，对于任意一个类A，如果不显式的声明和定义上述函数，那么编译器会自动为A产生4个public inline的默认函数

   ```c++
   A()//默认构造函数
   A(constA& a)//默认拷贝构造函数
   ~A()//默认析构函数
   A& operator = (const A& a)//默认赋值函数
   ```

4. **深拷贝与浅拷贝**
   浅拷贝是使两个指针指向同一个内存，本质上是两个对象共用一个实体，若对其中一个变量更改，另一个变量也会更改
   深拷贝是复制了一份，对一个变量的更改不会影响到另一个变量，深拷贝时需要再开辟一块空间存在实体。

5. **空类有哪些函数，空类的大小**
   根据第三点，4个默认函数，构造函数、析构函数、拷贝构造函数、赋值函数。
   一个占位符，大小为1。

6. **内存分区**
   从低地址到高地址分别为：
   代码区-》常量数据区-》全局区-》堆-》未使用区域《-栈
   代码区(.text)：存放代码，只读；
   数据区(.data)：存放常量，不允许修改，程序运行结束时自动释放
   全局区(.data与.bss)：存放全局变量与静态变量，程序运行结束时自动释放
   堆：存放程序内，动态申请的内存空间，由程序控制分配与释放
   栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配与释放。

7. **struct内存对齐**

   4字节对齐，即不满4字节需要对齐至4字节；
   连续多个同类型对象相互之间不需要对齐；
   不同类型的对象需要内存对齐；
   如果有虚函数，对象最开始是虚函数表指针，占用一个指针的空间

   ```C++
   struct A{
       char a;
       int b;
   };//sizeof(A) = 8,a占1字节，但是a,b需要对齐
   struct B{
       char a;
       char c;
       int b;
   };//sizeof(B) = 8,a,c不需要对齐，c，b需要对齐
   struct C{
       char a;
       char c;
       int b;
       virtual void d() = 0;
   };//sizeof(C) = 16,多了一个的虚函数指针，如果使用64位编译器则为16，如果使用32位编译器则为12
   struct D{};//sizeof(D) = 1，只有一个占位符
   ```

8. new/delete与malloc/free的区别
   new会先malloc一个对象size的内存，然后调用构造函数，delete也会先调用析构函数，然后调用free释放内存。

9. 内存泄露的情况

   是指程序中己动态分配的**堆内存**由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
   导致内存泄露的情况：

   1. 错误使用new/delete，new与delete需要匹配使用，new的对象需要delete释放掉；
   2. 释放对象数组时，``char* p = new char[10]``必须要``delete []a``将整个对象数组释放掉；
   3. 缺少拷贝构造函数：在类里存在成员变量是指针时，在进行赋值=运算和按值传参时，必须重载拷贝构造函数，重新实现其指针拷贝的部分；
   4. 没有将基类的析构函数定义为虚函数，对于一个子类的对象，析构的时候，应该先调用子类的析构函数，再调用基类的析构函数，因此需要将基类的析构函数定义为虚函数。

10. sizeof与strlen对比
    sizeof是关键字，返回值为对象的长度，strlen为字符串的长度，以‘\0’作为结束标记。

    ```C++
    char str[20] = "0123456789";
    strlen(str);//10，str字符串长度为10
    sizeof(str);//20,str这个对象在内存中的大小为20
    char *p = "12345";
    strlen(p);//5, 字符串长度为5
    sizeof(p);//4或8，一个char型指针，长度由编译器决定
    ```

11. 指针与引用的区别
    指针为一直存放地址的变量，引用为一个实体的别名，对引用进行更改操作会直接影响实体，进而影响所有的引用，指针可以为空，但是引用不能为空，必须和实体进行绑定。指针可以多层嵌套，即一个指针可以指向一个指针变量，引用不可以多层嵌套，不可以引用一个对象的引用。

12. 野指针的产生与避免
    野指针是指访问一个已销毁或者访问受限的内存区域的指针；
    垂悬指针是指一个正常指针但是对象被销毁后指针并未置空，形成了垂悬指针；
    产生原因：

    1. 指针定义时未被初始化， 会随机指向一个区域；

    2. 指针被释放时未置空；

    3. 指针操作超过变量 作用域，不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放。

       避免方法：初始化时将指针置空，以及释放时将指针置空

13. 静态多态与动态多态
    多态可以简单的概括为“一个接口，多种方法”；
    **静态多态**：是指在编译过程中的多态，编译器根据函数实参的类型，推断出要调用的函数。包括**函数重载**以及**函数模板的使用**两种实现方式。

    **动态多态（动态绑定）**：即运行时的多态，在程序执行期间判断其实际类型调用相应的方法。通过**虚函数**来实现动态绑定。

14. 虚函数实现动态多态的原理、虚函数与纯虚函数的区别
    纯虚函数是为了实现一个接口，规范继承这个类的子类必须实现这个函数。

15. 继承时，父类的析构函数为虚函数，构造函数不允许是虚函数
    因为子类的对象在析构时，应该要先调用子类的析构函数，再调用父类的析构函数，所以需要将父类的析构函数设置为虚函数。
    调用构造函数时，对象的内存空间还未分配，调用虚函数需要用到虚函数指针，而此时对象的虚函数指针还尚未分配，无法实现，因此不能将构造函数设置为虚函数。

16. 静态多态：重载、模板
    同名函数，形参不同，在编译的时候，根据实参的类型选择执行的函数。
    利用template实现多态，根据输入类型去初始化对象。

17. static关键字：修饰局部变量与全局变量，类中的成员变量与成员函数
    修饰局部变量时，会延长局部变量的生命周期，在函数块结束后不会被销毁，而是程序结束时才会被销毁，静态局部变量存放在全局区，缺省初始化为0，且只会被初始化一次。
    修饰全局变量时，只能在当前cpp文件中访问，不允许在其他cpp文件中使用extern后访问。
    类中的静态成员函数与静态成员变量：他们不属于某个对象，而是属于这一个类，因此可以直接调用这个类的成员函数/成员变量，不需要实例化的对象。

18. const关键字：修饰变量、指针、类对象、类成员函数

    ```
    const* int p = &a;//*p不允许修改
    int const* p = &a;//*p不允许修改
    int* const p = &a;//p不允许修改
    ```

    const修饰类的成员变量时，构造函数必须要在初始化列表中对该成员变量进行初始化；
    const修饰的成员函数时，成员函数不能兑数据成员进行修改操作，只能调用const成员函数，const对象只能调用const成员函数。

19. extern关键字：修饰全局变量

20. volatile关键字：禁止优化
    需要每次使用都去内存中读取数值，而不是读寄存器中的值。

21. 类型转换：static_cast, const_cast, dynamic_cast, reinterpret_cast
    static_cast强制类型转换，``void* p = static_cast<void*>(c);//将指针c强制类型转换为void*型指针``
    dynamic_cast进行类型检查的类型转换
    const_cast去掉const或者volatile属性

    ```
    const int g = 20;
    int* h = const_cast<int *>(&g);//去除const常量的const属性
    ```

    reinterpret_cast把一个指针转换为一个整数，或者一个整数转换为一个指针。

22. 四种智能指针及底层实现：unique_ptr、shared_ptr、weak_ptr
    unique_ptr无法进行拷贝构造和赋值操作，一个实体只允许被一个指针占有。可以移动构造与移动赋值构造，即一个unique_ptr对象赋值给另一个unique_ptr对象。
    shared_ptr：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。
    weak_ptr是为了解决shared_ptr循环引用的问题，weak_ptr不能通过它直接使用资源，可以通过lock来获得一个shared_ptr的对象来对资源进行使用。使用weak_ptr并不会增加资源的引用计数，所以对资源的引用是弱引用。

23. vector与list比较
    vector连续地址，访问时间O(1)，插入删除时间O(n)，除了push_back()和pop_back()时间O(1)；
    list离散地址，访问时间O(n)，插入删除时间O(1)；
    vector存在扩容情况，扩容需要花费大量时间，如果经常插入删除用list，否则用vector。

24. vector迭代器失效的情况
    当使用insert()、erase()时，insert与erase的点之后的迭代器全部失效；
    当发生扩容时，全部迭代器失效。

25. map与unordered_map对比
    map与unordered_map均是存储的key-value的值，通过key快速索引到value。
    map的底层实现是红黑树，需要对key进行排序，查询效率较低，占用内存少；
    unordered_map底层实现是hashtable，即``vector<list<pair<int,  value_type>>>``，先对key取hash函数，将key映射到一个bucket的index，然后将key-value插入到list中。查询速度比map高。

    unordered_map同样存在扩容，如果某一个bucket的list过长，就会导致查找速度降低（list查找效率O(n)），因此需要对其扩容，将数组长度扩容到最接近两倍的质数长度，然后再将所有的数据重新放入。

26. set与unordered_set对比

    与25的对比类似，set底层实现为红黑树，unordered_set底层实现为hashtable。

    ![img](.\70)

    最坏情况是所有的key都映射到一个bucket。

## 计网

1. OSI7层模型：应用层，表示层，会话层，传输层，网络层，链路层，物理层
   **应用层**：应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。
   **表示层**表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。
   **会话层**会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。
   **传输层**传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
   **网络层**两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把运输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。
   **数据链路层**数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。
   **物理层**作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。
2. TCP/IP五层模型：应用层，传输层，网络层，数据链路层，物理层
   传输层建立端口到端口的连接，网络层建立IP地址到IP地址的连接。

链路层：

3. MAC地址：MAC是写在网卡上的物理地址，每个网络设备都有独一无二的MAC地址，MAC地址是数据链路层和物理层使用的地址，MAC地址用来定义网络设备的位置。
   IP地址：IP地址是网络层和以上层使用的逻辑地址，IP地址用来区分网络上的计算机。

网络层：

4. 地址解析协议（Address Resolution Protocol ARP协议）
   每个主机都会在自己的ARP缓存区建立ARP列表，表示IP地址和MAC地址的对应关系，如果有目标IP地址对应的MAC地址，则直接发送，不存在就向子网的所有数据广播ARP数据包，包含源主机IP，MAC地址，已经目标IP，如果接受到的主机IP与目标IP相同，则主机会发送自己的MAC地址写入ARP响应包中发送给源主机。

5. 为什么同时需要IP地址和MAC地址
   我们需要用IP地址来区分网络设备属于哪一个子网，在路由时用IP地址来寻找网络设备所在的子网；
   我们需要用MAC地址来区分不同的设备，例如在分配IP地址时，需要用MAC地址来识别不同的网络设备。

6. 网络层转发与接收数据报文的流程
   **转发：**应用程序调用系统调用，将数据发送给socket
   socket检查数据类型，调用相应的send函数
   send函数检查socket状态、协议类型，传给传输层
   tcp/udp（传输层协议）为这些数据创建数据结构，加入协议头部，比如端口号、检验和，传给下层（网络层）
   ip（网络层协议）添加ip头，比如ip地址、检验和
   如果数据包大小超过了mtu（最大数据包大小），则分片；ip将这些数据包传给链路层
   链路层写到网卡队列
   网卡调用响应中断驱动程序，发送到网络
   **接收：**数据包从网络到达网卡，网卡接收帧，放入网卡buffer，在向系统发送中断请求
   cpu调用相应中断函数，这些中断处理程序在网卡驱动中
   中断处理函数从网卡读入内存，交给链路层
   链路层将包放入自己的队列，置软中断标志位
   进程调度器看到了标志位，调度相应进程
   该进程将包从队列取出，与相应协议匹配，一般为ip协议，再将包传递给该协议接收函数
   ip层对包进行错误检测，无错，路由
   路由结果，packet被转发或者继续向上层传递
   如果发往本机，进入链路层
   链路层再进行错误侦测，查找相应端口关联socket，包被放入相应socket接收队列

   socket唤醒拥有该socket的进程，进程从系统调用read中返回，将数据拷贝到自己的buffer，返回用户态。

传输层：

7. TCP/UDP的区别及应用场景
   TCP是面向连接的可靠的传输协议，UDP是面向非连接的快速的传输协议；
   TCP是端口到端口之间的传输，只支持一对一，UDP支持一对一，一对多，多对多；
   TCP是可靠的传输协议，进行的可靠交付，无差错、不重复、不丢失、按序到达，UDP是不可靠的传输协议，不能保证可靠交付；
   TCP有拥塞控制和流量控制保证数据传输的安全性，UDP没有拥塞控制，当网络拥塞时不会影响源主机的发送效率；
   TCP首部开销大，TCP报文头部占20字节，UDP首部开销相对小，占用8字节。
   TCP的适用场景：要求通信数据的完整性和准确性较高，例如文件传输；
   UDP的使用场景：要求通信的响应度高，对数据信息的安全性和完整性要求相对较低，常用于实时通信。
8. TCP首部报文格式（SYN、ACK、FIN、RST必须知道）
   ![](.\1612460289-ImAroH-TCP报文格式.png)
9. TCP滑动窗口原理
   对于发送方来说，窗口内的包括发送窗口（已经发送了，但是没有收到ACK），可用窗口（接收端允许发送，但是还没有发送的部分），窗口的长度在建立TCP连接时被设定。即不需要因为一个包未收到ACK而长时间暂停，而是一边发送数据，一边接受之前发送报文的ACK。
10. TCP拥塞控制与流量控制
    流量控制是为了解决发送方和接收方速度不同而导致的数据丢失问题，当发送方发送的太快，接收方来不及接受就会导致数据丢失，流量控制用滑动窗口来解决；
    拥塞控制是为了解决过多的数据注入到网络，导致网络奔溃，拥塞控制通过慢启动，快重传，快恢复来解决。
    滑动窗口：简单来说就是发送窗口的大小,取接受方ACK提供的大小和发送方的拥塞窗口大小的最小值,来确定大小,发送窗口的大小不能超过滑动窗口的大小.为什么称为滑动窗口,因为当发送方接收到数据的确认信息,滑动窗口会更具返回的序号动态的改变窗口的位置.滑动的窗口大小得到了重置,同时滑动窗口会根据网络状况动态变化.
    拥塞控制：
    慢开始：是先将窗口设置为1，然后每轮大小增长一倍，直到门限值；
    拥塞避免：慢开始结束后,接下来就是拥塞避免,这个阶段拥塞窗口在每个传输轮次数量加1,直到触发了网络拥塞,窗口大小和门限都变为拥塞时最大的值得一半,然后重新开始慢开始阶段
    快重传：快重传指的是当接受方收到顺序错误得数据时不接收数据,同时重复发起对于之前数据的确认,发动到第三次,发送方得知自己的一部分数据再发送中丢失,立即发起重传,不需要等待下一次发送信息时一起发送过去.,且重传时触发和拥塞一样得情况,进入快恢复阶段；
    快恢复：快恢复就是再发生拥塞和重传时,窗口经历了拥塞避免阶段,然后进入快恢复阶段,和拥塞避免一样都是每次加一,这样能提高恢复速度,像老版本(Tahoe)中需要重新经历慢开始。
11. TCP三次握手
    ![](.\1614160878-FiFlkq-image.png)
12. TCP四次挥手
    ![](.\1612459478-ajInIu-四次挥手.png)
13. TCP释放连接时TIME_WAIT状态的作用
    有可能服务端未收到确认包，会重发FIN+ACK包，如果没有TIME_WAIT阶段会导致重发的FIN+ACK无法收到，服务端无法正常释放连接，因此需要等待2MSL时间。
14. 路由器与交换机的区别
    路由器工作在网络层，交换机工作在链路层；
    路由器工作：寻址，转发；
    交换机工作：过滤，转发；
15. 如何利用UDP实现可靠传输
    TCP传输具有可靠性，但TCP连接传输速度慢，报文头部较长导致传输效率低，产生队头阻塞等问题，随着对传输速度的要求越来越高，TCP逐渐不满足需求。因此需要在UDP的基础上，在应用层实现其可靠性，建立一个快速的可靠的传输协议。HTTP3.0就采用了基于UDP的QUIC传输协议。
    UDP在应用层实现确认机制，重传机制与窗口确认机制，实现传输的可靠性。
    QUIC特定：
    1. 低延迟连接的建立![img](.\20180109113108151)
    2. 改进的拥塞控制
       可拔插：在应用层实现，可以更新应用层来更新
       单调递增的PacketNumber:QUIC采用PacketNumber来确认消息，每个PacketNumber严格递增，解决了TCP重传的歧义问题；
       更多的ACK块，精确计算的RTT时间
    3. 无队头阻塞的多路复用：HTTP2的最大特性就是多路复用，而HTTP2最大的问题就是队头阻塞。首先了解下为什么会出现队头阻塞。比如HTTP2在一个TCP连接上同时发送3个stream，其中第2个stream丢了一个Packet，TCP为了保证数据可靠性，需要发送端重传丢失的数据包，虽然这时候第3个数据包已经到达接收端，但被阻塞了。这就是所谓的队头阻塞。而QUIC多路复用可以避免这个问题，因为QUIC的丢包、流控都是基于stream的，所有stream是相互独立的，一条stream上的丢包，不会影响其他stream的数据传输。
    4. 前向纠错：通过纠错包和接收到的数据包可以解出丢失的包，无需重复发送，如果接受数据包加上纠错包的数量大于发送数据包的数量即可解出全部数据包。
    5. 连接迁移：QUIC使用64位的Connection ID进行唯一识别客户端与服务端的逻辑连接，如果IP地址或者端口号改变了，只要客户端与服务端不改变，就仍然采用老的ConnectionID，且连接保持不变。

应用层

16. HTTP请求报文与响应报文首部结构

    发送报文首部：
    请求行：请求方法字段，URL字段，协议版本字段
    请求头部：选择必要的请求头，发送内容
    请求数据：如果需要提交数据，就放置提交的数据。

    ![](C:\Users\Administrator\Desktop\learning\cpp\20160921092902556.jpg)
    接收报文首部：
    响应行：协议版本号，状态码与状态描述
    响应头：响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。
    响应体：响应体就是响应的信息体，如果请求的是纯数据就返回纯数据，如果请求的是HTML页面，那么就返回HTML页面。
    ![](C:\Users\Administrator\Desktop\learning\cpp\20160921092902557.jpg)

17. HTTP1.0, HTTP1.1, HTTP2.0, HTTP3.0对比
    HTTP1.0默认短连接，其他协议默认长连接；
    HTTP2.0支持多路复用，一个HTTP请求可以实现多个HTTP请求传输，客户端和服务端通过流ID来识别。HTTP2.0头部压缩，提高传输效率；
    HTTP3.0使用基于UDP的QUIC传输协议。

18. HTTP和HTTPS对比
    HTTP是明文传输的，HTTPS是HTTP建立在TLS加密上的协议。

19. HTTPS加密过程
    RSA交换密钥步骤：

    1. 客户端给出协议版本号，一个随机数（Random1），以及客户端支持的加密方法；
    2. 服务端确认使用的加密方法，并给出数字证书，以及随机数（random2);
    3. 客户端确认数字证书有效，生成一个新的随机数（premaster secret），并使用数字证书中的公钥，利用RSA算法加密这个随机数，发送给服务端；
    4. 服务端使用自己的私钥，获取客户端发送来的随机数（premaster secret);
    5. 客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成对话密钥（master secret），用来加密接下来的整个对话过程。

20. 输入一个URL到显示页面的流程

    1. DNS域名解析；
    2. 建立TCP连接；
    3. 发送HTTP请求；
    4. 服务器处理请求；
    5. 返回响应结果；
    6. 关闭TCP连接；
    7. 浏览器解析HTML；
    8. 浏览器布局渲染。

## 操作系统

1. 进程与线程的区别
   进程是分别资源的的最小单位，线程是处理器调度的最小单位，一个进程由一个或者多个线程组成。
   
2. 互斥锁和自旋锁的底层实现
   互斥锁是在一个线程持有锁的时候，其他的线程对临界区的访问会被阻塞。
   自旋锁与互斥锁类似，但是不是阻塞访问临界区的线程，而是让线程一直循环查看锁是否被释放，效率高，但是会一直占用CPU；
   
3. 孤儿进程与僵尸进程：
   孤儿进程是指父进程已经退出，他的子进程还在运行，孤儿进程会被init进程（pid = 1，孤儿院院长）收养。
   僵尸进程是指一个子进程退出后没有回收资源，导致进程描述符仍然存在，占用资源。
   
4. 多线程与多进程的比较
   进程之间切换，通信的代价都很大，进程与进程之间几乎不会相互影响，同步较为简单，适用于多核、多机的分布式；
   线程共享数据简单，一个进程下的不同线程，除了堆之外都是共享的，占用内存小，切换简单，创建销毁简单，速度很快，一个线程挂掉会导致整个进程挂掉，适用于多核分布式。
   
5. 进程间通信IPC：pipe，FIFO，消息队列，信号，共享内存，socket。

6. fork进程的底层实现：读时共享，写时复制。

7. 线程上下文切换与进程上下文切换
   进程上下文切换与线程上下文切换最主要的区别是线程切换的虚拟空间是一样的，都是在同一进程下，进程是分配资源的最小单位，进程切换的虚拟内存是不同的。
   
8. 阻塞IO与非阻塞IO
   阻塞IO：资源不可用时，IO请求一直阻塞，直到反馈结果；
   非阻塞IO：资源不可以时，IO请求离开返回，返回数据标识资源不可用。
   
9. MMU地址翻译过程
   <img src=".\image004.png" style="zoom:150%;" />
   
10. IO多路复用的三种机制select, poll, epoll
      I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。

   1. select：select提供了一种fd_set的数据结构，每一个数组元素为一个文件描述符，当调用select()时，有内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一个socket或文件可读。

   2. poll：poll的机制与select类似，但是没有最大文件描述符数量的限制，采用的是链表的数据结构，而不是select中使用的数组来管理。

   3. epoll：epoll是基于事件驱动的IO方式，epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。

      * **水平触发（LT）：**默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件
      * **边缘触发（ET）：** 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。

      ![image-20210428112524820](.\image-20210428112524820.png)

11. Unix中的5种IO模型

    1. 阻塞IO（blocking IO）：在linux中，默认情况下所有socket都是blocking，用户进程调用了阻塞IO后进程会被阻塞，直到从kernel返回结果才会重新运行；
    2. 非阻塞IO（NoneBlocking IO）：进程会每隔一段时间去检查数据是否已经准备好，不断的主动询问kernel数据是否准备好。
    3. IO多路复用（IO multiplexing）：I/O多路复用(multiplexing)是网络编程中最常用的模型，像我们最常用的select、epoll都属于这种模型。看起来它与blocking I/O很相似，两个阶段都阻塞。但它与blocking I/O的一个重要区别就是它可以等待多个数据报就绪（datagram ready），即可以处理多个连接。
    4. 信号驱动IO（signal driven IO）
    5. 异步IO（asynchronous IO）：这里的读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。

    ![img](.\webp1)

